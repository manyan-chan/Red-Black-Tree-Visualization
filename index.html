<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        .node-red {
            fill: #e53e3e;
            stroke: #742a2a;
        }

        .node-black {
            fill: #1a202c;
            stroke: #4a5568;
        }

        .dark .node-black {
            fill: #4a5568;
            stroke: #1a202c;
        }

        .node-text {
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            user-select: none;
            font-size: 1rem;
        }

        .dark .node-text {
            fill: white;
        }

        .node-red .node-text {
            fill: white;
        }

        .edge {
            stroke: #4a5568;
            stroke-width: 2;
        }

        .dark .edge {
            stroke: #a0aec0;
        }

        #canvas-container {
            touch-action: none;
            /* Prevent default touch actions like scrolling when interacting with SVG */
            min-height: 400px;
            /* Ensure container has a minimum height */
            position: relative;
            /* Needed for absolute positioning if used later */
            overflow: hidden;
            /* Clip content exceeding bounds, rely on SVG pan/zoom */
            border: 1px solid #e2e8f0;
            /* Optional: add border for clarity */
        }

        .dark #canvas-container {
            border: 1px solid #4a5568;
        }

        #rbTreeCanvas {
            display: block;
            /* Remove extra space below SVG */
            width: 100%;
            height: 100%;
            /* Make SVG fill the container */
            cursor: grab;
        }

        #rbTreeCanvas:active {
            cursor: grabbing;
        }
    </style>
</head>

<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col">
    <div class="container mx-auto px-4 py-8 flex-grow">
        <h1 class="text-3xl font-bold text-center mb-6">Red-Black Tree Visualization</h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1 bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow">
                <h2 class="text-xl font-semibold mb-4">Controls</h2>

                <div class="mb-4">
                    <label for="nodeValue" class="block mb-2">Insert Node:</label>
                    <div class="flex">
                        <input type="number" id="nodeValue" placeholder="Enter value" min="1" max="999"
                            class="flex-grow px-3 py-2 border rounded-l-md text-gray-900 dark:text-gray-100 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary text-base">
                        <button id="insertBtn"
                            class="bg-primary hover:bg-primary/80 text-white font-bold py-2 px-4 rounded-r-md">
                            Insert
                        </button>
                    </div>
                </div>

                <div class="mb-4">
                    <label for="deleteValue" class="block mb-2">Delete Node:</label>
                    <div class="flex">
                        <input type="number" id="deleteValue" placeholder="Enter value" min="1" max="999"
                            class="flex-grow px-3 py-2 border rounded-l-md text-gray-900 dark:text-gray-100 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary text-base">
                        <button id="deleteBtn"
                            class="bg-primary hover:bg-primary/80 text-white font-bold py-2 px-4 rounded-r-md">
                            Delete
                        </button>
                    </div>
                </div>

                <div class="mb-4">
                    <button id="resetBtn"
                        class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">
                        Reset Tree
                    </button>
                </div>

                <div class="mb-4">
                    <button id="randomTreeBtn"
                        class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">
                        Generate Random Tree
                    </button>
                </div>

                <div id="status" class="mt-4 p-2 bg-gray-200 dark:bg-gray-700 rounded-md min-h-10 hidden"></div>
            </div>

            <div class="md:col-span-2 bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow flex flex-col">
                <h2 class="text-xl font-semibold mb-4">Tree Visualization</h2>
                <div id="canvas-container" class="flex-grow w-full bg-white dark:bg-gray-700 rounded-lg">
                    <svg id="rbTreeCanvas"></svg>
                </div>
                <div class="flex justify-center mt-4 space-x-2">
                    <button id="zoomInBtn" title="Zoom In"
                        class="bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-3 py-1 rounded-md">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                        </svg>
                    </button>
                    <button id="zoomOutBtn" title="Zoom Out"
                        class="bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-3 py-1 rounded-md">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 12H6" />
                        </svg>
                    </button>
                    <button id="resetViewBtn" title="Reset View"
                        class="bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-3 py-1 rounded-md">
                        Reset View
                    </button>
                </div>
            </div>

            <div class="md:col-span-3 bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow">
                <h2 class="text-xl font-semibold mb-4">Red-Black Tree Properties</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-semibold mb-2">Properties:</h3>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>Every node is either red or black</li>
                            <li>The root is black</li>
                            <li>All leaves (NIL) are black</li>
                            <li>If a node is red, then both its children are black</li>
                            <li>Every path from a node to any of its descendant NIL nodes contains the same number of
                                black nodes</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="font-semibold mb-2">Balancing Operations:</h3>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>Color changes</li>
                            <li>Left rotation</li>
                            <li>Right rotation</li>
                            <li>These operations ensure O(log n) time complexity for search, insert, and delete</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark')
        } else {
            document.documentElement.classList.remove('dark')
        }

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            visualizer?.updateView(); // Redraw to apply color changes
        });


        class Node {
            constructor(value) {
                this.value = value;
                this.color = "RED";
                this.left = null; // Will be set to NIL
                this.right = null; // Will be set to NIL
                this.parent = null; // Will be set during insertion or rotation
            }
        }

        class RedBlackTree {
            constructor() {
                this.NIL = { color: "BLACK", left: null, right: null, parent: null, value: null, isNIL: true };
                // Setting NIL's children/parent to itself can sometimes simplify checks, but null is also fine if handled. Let's keep null.
                this.NIL.left = this.NIL;
                this.NIL.right = this.NIL;
                this.NIL.parent = this.NIL; // Parent of NIL isn't really used, but consistency helps
                this.root = this.NIL;
                this.nodeCount = 0;
            }

            insert(value) {
                let newNode = new Node(value);
                newNode.left = this.NIL;
                newNode.right = this.NIL;
                newNode.parent = null; // Parent determined below

                let y = null; // Trailing pointer for parent
                let x = this.root; // Current node

                while (x !== this.NIL) {
                    y = x;
                    if (newNode.value < x.value) {
                        x = x.left;
                    } else if (newNode.value > x.value) {
                        x = x.right;
                    } else {
                        return; // Value already exists, do nothing
                    }
                }

                newNode.parent = y; // Link new node to its parent
                if (y === null) { // Tree was empty
                    this.root = newNode;
                } else if (newNode.value < y.value) {
                    y.left = newNode;
                } else {
                    y.right = newNode;
                }

                this.nodeCount++;

                // New node is RED by default. Check for violations.
                if (newNode.parent === null) { // Inserted as root
                    newNode.color = "BLACK"; // Root must be black
                    return;
                }

                // If parent is root (grandparent is null), no red-red violation possible yet
                if (newNode.parent.parent === null) {
                    return;
                }

                // Perform fixup if needed (parent is RED)
                this.fixInsert(newNode);
            }

            fixInsert(k) {
                let u; // Uncle node
                // Loop while parent is RED (violates property 4)
                // k.parent check is safe because root's parent is null (checked in insert)
                // k.parent.parent check is safe because child-of-root case is handled in insert
                while (k.parent.color === "RED") {
                    // Parent is the right child of grandparent
                    if (k.parent === k.parent.parent.right) {
                        u = k.parent.parent.left; // Uncle
                        if (u.color === "RED") {
                            // Case 1: Uncle is RED -> Recolor parent, uncle, grandparent
                            u.color = "BLACK";
                            k.parent.color = "BLACK";
                            k.parent.parent.color = "RED";
                            k = k.parent.parent; // Move up to grandparent to check further
                        } else {
                            // Case 2 & 3: Uncle is BLACK
                            if (k === k.parent.left) {
                                // Case 2: k is left child (triangle) -> Rotate parent right
                                k = k.parent;
                                this.rightRotate(k);
                                // After rotation, k points to the original child node (now the lower node)
                                // k.parent is now the original grandparent
                            }
                            // Case 3: k is right child (line) -> Recolor and rotate grandparent left
                            // This also handles Case 2 after the rotation
                            k.parent.color = "BLACK"; // New parent (original grandparent or original parent after rotation)
                            k.parent.parent.color = "RED"; // New grandparent (original great-grandparent or original grandparent's parent)
                            this.leftRotate(k.parent.parent);
                        }
                    } else { // Parent is the left child of grandparent
                        u = k.parent.parent.right; // Uncle
                        if (u.color === "RED") {
                            // Case 1: Uncle is RED -> Recolor parent, uncle, grandparent
                            u.color = "BLACK";
                            k.parent.color = "BLACK";
                            k.parent.parent.color = "RED";
                            k = k.parent.parent; // Move up
                        } else {
                            // Case 2 & 3: Uncle is BLACK
                            if (k === k.parent.right) {
                                // Case 2: k is right child (triangle) -> Rotate parent left
                                k = k.parent;
                                this.leftRotate(k);
                            }
                            // Case 3: k is left child (line) -> Recolor and rotate grandparent right
                            k.parent.color = "BLACK";
                            k.parent.parent.color = "RED";
                            this.rightRotate(k.parent.parent);
                        }
                    }
                    // If k moved up to the root, exit loop
                    if (k === this.root) {
                        break;
                    }
                }
                // Ensure root is always black (Property 2)
                this.root.color = "BLACK";
            }


            leftRotate(x) {
                let y = x.right; // Set y
                x.right = y.left; // Turn y's left subtree into x's right subtree
                if (y.left !== this.NIL) {
                    y.left.parent = x; // Update parent pointer of y's left child
                }
                y.parent = x.parent; // Link y's parent to x's parent
                if (x.parent === null) { // x was root
                    this.root = y;
                } else if (x === x.parent.left) { // x was left child
                    x.parent.left = y;
                } else { // x was right child
                    x.parent.right = y;
                }
                y.left = x; // Put x on y's left
                x.parent = y; // Set x's parent to y
            }

            rightRotate(x) {
                let y = x.left; // Set y
                x.left = y.right; // Turn y's right subtree into x's left subtree
                if (y.right !== this.NIL) {
                    y.right.parent = x; // ***** CORRECTED LINE ***** Update parent pointer
                }
                y.parent = x.parent; // Link y's parent to x's parent
                if (x.parent === null) { // x was root
                    this.root = y;
                } else if (x === x.parent.right) { // x was right child
                    x.parent.right = y;
                } else { // x was left child
                    x.parent.left = y;
                }
                y.right = x; // Put x on y's right
                x.parent = y; // Set x's parent to y
            }

            transplant(u, v) {
                // Replaces subtree rooted at u with subtree rooted at v
                if (u.parent === null) {
                    this.root = v;
                } else if (u === u.parent.left) {
                    u.parent.left = v;
                } else {
                    u.parent.right = v;
                }
                // Set parent of v only if v is not NIL
                // Note: v might be NIL, NIL.parent points to NIL (or null if defined differently)
                // The check v !== this.NIL correctly handles this.
                if (v !== this.NIL) {
                    v.parent = u.parent;
                }
            }


            minimum(node) {
                // Finds the node with the minimum value in the subtree rooted at node
                while (node.left !== this.NIL) {
                    node = node.left;
                }
                return node;
            }

            deleteNodeHelper(node, key) {
                // Finds the node with the given key starting from 'node'
                let z = this.NIL; // Node to be deleted
                let searchNode = node; // Use a separate var for searching
                while (searchNode !== this.NIL) {
                    if (searchNode.value === key) {
                        z = searchNode;
                        break; // Found node to delete
                    }
                    // Standard BST search
                    if (searchNode.value < key) {
                        searchNode = searchNode.right;
                    } else {
                        searchNode = searchNode.left;
                    }
                }

                if (z === this.NIL) {
                    return false; // Node not found
                }

                this.nodeCount--; // Decrement count only if node found
                let y = z; // y is the node either removed or moved
                let yOriginalColor = y.color;
                let x; // x is the child that replaces y

                if (z.left === this.NIL) {
                    x = z.right; // x might be NIL
                    this.transplant(z, z.right);
                } else if (z.right === this.NIL) {
                    x = z.left; // x cannot be NIL here (because z.left wasn't NIL)
                    this.transplant(z, z.left);
                } else {
                    // z has two children. Find successor (minimum in right subtree)
                    y = this.minimum(z.right);
                    yOriginalColor = y.color;
                    x = y.right; // Successor's right child (might be NIL)

                    if (y.parent === z) {
                        // If y is z's direct child, x's parent should point to y after transplant.
                        // If x is NIL, its parent doesn't matter initially, transplant handles v's parent.
                        // We only need to explicitly set if x exists and needs its parent updated *before*
                        // the later transplant of y. In this case, it's simpler: x moves with y.
                        if (x !== this.NIL) x.parent = y; // Crucial if x becomes child of y directly
                    } else {
                        // y is further down. Replace y with its right child first.
                        this.transplant(y, y.right);
                        // Attach z's right subtree to y
                        y.right = z.right;
                        y.right.parent = y;
                    }
                    // Replace z with y
                    this.transplant(z, y);
                    // Attach z's left subtree to y
                    y.left = z.left;
                    y.left.parent = y;
                    // Give y z's color
                    y.color = z.color;
                }

                // If the node removed (or the node moved into the removed node's place)
                // was black, the black-height property might be violated.
                if (yOriginalColor === "BLACK") {
                    this.fixDelete(x); // Fix starting from the node that replaced y
                }
                return true; // Deletion successful
            }


            fixDelete(x) {
                let s; // sibling
                // Loop while x is not root AND x is black (double black or red-black)
                // If x is red-black, the loop terminates after one iteration by setting x to black.
                // If x is NIL, it's treated as black.
                while (x !== this.root && (x === this.NIL || x.color === "BLACK")) {
                    // x must have a parent if it's not the root.
                    // NIL nodes conceptually have parents in this implementation.
                    let xParent = x.parent;
                    if (!xParent || xParent === this.NIL) break; // Should not happen if tree is correct

                    if (x === xParent.left) { // x is left child
                        s = xParent.right; // Sibling

                        // Case 1: Sibling s is RED
                        if (s.color === "RED") {
                            s.color = "BLACK";
                            xParent.color = "RED";
                            this.leftRotate(xParent);
                            s = xParent.right; // New sibling is now black (was s's child)
                        }

                        // Now sibling s MUST be BLACK (due to Case 1 or initially)
                        let sLeftIsBlack = (s.left === this.NIL || s.left.color === "BLACK");
                        let sRightIsBlack = (s.right === this.NIL || s.right.color === "BLACK");

                        // Case 2: Sibling s is BLACK, both s's children are BLACK
                        if (sLeftIsBlack && sRightIsBlack) {
                            s.color = "RED"; // Push blackness up to parent
                            x = xParent; // Move up the tree
                        } else {
                            // Case 3: Sibling s is BLACK, s.left is RED, s.right is BLACK (Triangle)
                            if (sRightIsBlack) {
                                if (s.left !== this.NIL) s.left.color = "BLACK";
                                s.color = "RED";
                                this.rightRotate(s);
                                s = xParent.right; // New sibling (original s.left)
                            }
                            // Case 4: Sibling s is BLACK, s.right is RED (Line)
                            // Also handles Case 3 after rotation
                            s.color = xParent.color; // Sibling takes parent's color
                            xParent.color = "BLACK"; // Parent becomes black
                            if (s.right !== this.NIL) s.right.color = "BLACK"; // Sibling's red child becomes black
                            this.leftRotate(xParent); // Rotate parent
                            x = this.root; // Problem solved, exit loop
                        }
                    } else { // x is right child (symmetric cases)
                        s = xParent.left; // Sibling

                        // Case 1: Sibling s is RED
                        if (s.color === "RED") {
                            s.color = "BLACK";
                            xParent.color = "RED";
                            this.rightRotate(xParent);
                            s = xParent.left; // New sibling is now black
                        }

                        // Now sibling s MUST be BLACK
                        let sLeftIsBlack = (s.left === this.NIL || s.left.color === "BLACK");
                        let sRightIsBlack = (s.right === this.NIL || s.right.color === "BLACK");

                        // Case 2: Sibling s is BLACK, both s's children are BLACK
                        if (sLeftIsBlack && sRightIsBlack) {
                            s.color = "RED";
                            x = xParent; // Move up
                        } else {
                            // Case 3: Sibling s is BLACK, s.right is RED, s.left is BLACK (Triangle)
                            if (sLeftIsBlack) {
                                if (s.right !== this.NIL) s.right.color = "BLACK";
                                s.color = "RED";
                                this.leftRotate(s);
                                s = xParent.left; // New sibling
                            }
                            // Case 4: Sibling s is BLACK, s.left is RED (Line)
                            // Also handles Case 3 after rotation
                            s.color = xParent.color;
                            xParent.color = "BLACK";
                            if (s.left !== this.NIL) s.left.color = "BLACK";
                            this.rightRotate(xParent);
                            x = this.root; // Problem solved, exit loop
                        }
                    }
                }
                // After loop, ensure x (which might be the root or a red node) becomes black
                if (x !== this.NIL) {
                    x.color = "BLACK";
                }
            }


            delete(value) {
                return this.deleteNodeHelper(this.root, value);
            }


            clear() {
                this.root = this.NIL;
                this.nodeCount = 0;
            }

            getHeight() {
                return this._getHeight(this.root);
            }

            _getHeight(node) {
                if (node === this.NIL) {
                    return 0;
                }
                // Recursively find height
                let leftHeight = this._getHeight(node.left);
                let rightHeight = this._getHeight(node.right);
                return 1 + Math.max(leftHeight, rightHeight);
            }

            find(value) {
                let current = this.root;
                while (current !== this.NIL) {
                    if (value === current.value) {
                        return current; // Return the actual node
                    }
                    if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                return null; // Use null conventionally for 'not found' outside the class
            }
        }


        class TreeVisualizer {
            constructor(svgElement, tree) {
                this.svg = svgElement;
                this.tree = tree;
                this.nodeRadius = 25;
                this.baseHorizontalSpacing = 30; // Min spacing between nodes
                this.verticalSpacing = 80;      // Vertical distance between levels
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.startDragX = 0;
                this.startDragY = 0;
                this.contentGroup = null; // Reference to the main <g> element for transformations

                this.svgContainer = svgElement.parentElement; // The div containing the SVG

                // Event Listeners
                this.svg.addEventListener('mousedown', this.startDrag.bind(this));
                this.svg.addEventListener('mousemove', this.drag.bind(this));
                this.svg.addEventListener('mouseup', this.endDrag.bind(this));
                this.svg.addEventListener('mouseleave', this.endDrag.bind(this));
                this.svg.addEventListener('wheel', this.handleWheelZoom.bind(this), { passive: false }); // Prevent page scroll

                this.svg.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false }); // Prevent default actions
                this.svg.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.svg.addEventListener('touchend', this.handleTouchEnd.bind(this));
                this.svg.addEventListener('touchcancel', this.handleTouchEnd.bind(this));

                // Button Listeners
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoom(1 / 1.2));
                document.getElementById('resetViewBtn').addEventListener('click', () => this.resetView());

                // Resize observer for container to reset view on container resize
                this.resizeObserver = new ResizeObserver(() => {
                    // Only reset if the tree isn't empty, avoid resetting on initial load sometimes
                    if (this.tree.root !== this.tree.NIL || this.contentGroup) {
                        this.resetView(false); // Reset view without redrawing initially if not needed
                    }
                });
                this.resizeObserver.observe(this.svgContainer);
            }

            handleWheelZoom(e) {
                e.preventDefault(); // Prevent page scroll
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1; // Zoom in on scroll up, out on scroll down
                this.zoom(zoomFactor);
            }

            startDrag(e) {
                this.isDragging = true;
                // Use clientX/Y for consistency across mouse/touch
                this.startDragX = e.clientX;
                this.startDragY = e.clientY;
                this.svg.style.cursor = 'grabbing'; // Feedback for dragging
            }

            drag(e) {
                if (!this.isDragging) return;
                const currentX = e.clientX;
                const currentY = e.clientY;
                // Calculate delta based on the change since the last move event
                const dx = currentX - this.startDragX;
                const dy = currentY - this.startDragY;
                // Update translation
                this.translateX += dx;
                this.translateY += dy;
                // Update the start position for the next drag event
                this.startDragX = currentX;
                this.startDragY = currentY;
                this.updateTransform(); // Apply the new transform
            }

            endDrag() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.svg.style.cursor = 'grab'; // Restore cursor
                }
            }

            // --- Touch Event Handlers ---
            handleTouchStart(e) {
                e.preventDefault(); // Prevent screen scrolling, etc.
                if (e.touches.length === 1) { // Handle single touch for panning
                    const touch = e.touches[0];
                    this.startDrag({ clientX: touch.clientX, clientY: touch.clientY }); // Simulate mouse event
                }
                // Future: Add pinch-zoom logic for e.touches.length === 2
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDragging) { // Pan only if dragging started
                    const touch = e.touches[0];
                    this.drag({ clientX: touch.clientX, clientY: touch.clientY }); // Simulate mouse event
                }
            }

            handleTouchEnd(e) {
                // If panning was occurring, end it
                this.endDrag();
            }


            zoom(factor) {
                const newScale = Math.max(0.1, Math.min(5, this.scale * factor)); // Clamp scale
                // Basic zoom towards center. Could be enhanced to zoom towards mouse/touch point.
                this.scale = newScale;
                this.updateTransform();
            }

            resetView(shouldRedraw = true) {
                // Reset scale
                this.scale = 1;

                // Reset translation to roughly center the initial view
                const containerWidth = this.svgContainer.clientWidth;
                const containerHeight = this.svgContainer.clientHeight;
                this.translateX = containerWidth / 2; // Center horizontally
                this.translateY = this.nodeRadius + 40; // Position near the top vertically

                this.updateTransform(); // Apply reset transform

                // Redraw the tree if requested (usually yes, except sometimes on resize)
                if (shouldRedraw) {
                    this.draw();
                }
            }


            updateTransform() {
                // Apply the current translation and scale to the content group
                if (this.contentGroup) {
                    // Transform origin is top-left (0,0) of the group by default
                    this.contentGroup.setAttribute('transform', `translate(${this.translateX}, ${this.translateY}) scale(${this.scale})`);
                }
            }


            draw() {
                // Clear previous drawing
                this.svg.innerHTML = '';
                // Create the main group element for transformations
                this.contentGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.contentGroup);

                if (this.tree.root === this.tree.NIL) {
                    this.updateTransform(); // Apply default transform even if empty
                    // Optionally display a message like "Tree is empty"
                    return;
                }

                // Calculate node positions using a layout algorithm
                const treeLayout = this.calculateLayout(this.tree.root);

                // Draw nodes and edges recursively based on calculated positions
                this.drawNodeAndEdges(this.contentGroup, treeLayout.rootPos);

                // Apply the current view transform (pan/zoom)
                this.updateTransform();
            }

            // Calculates node positions using a simple in-order traversal for X
            // and depth for Y, then attempts basic centering.
            // More sophisticated algorithms (e.g., Reingold-Tilford) provide better spacing.
            calculateLayout(node) {
                const positions = new Map(); // Map node object to {node, x, y, children:[]}
                let nextX = 0;
                let minY = 0, maxY = 0, minX = 0, maxX = 0; // Track bounds

                // First pass: Assign initial X based on in-order traversal, Y based on depth
                function computeInitialPositions(n, depth) {
                    if (n === this.tree.NIL) {
                        return;
                    }

                    // Recurse left
                    computeInitialPositions.call(this, n.left, depth + 1);

                    // Assign current node's position
                    const x = nextX;
                    const y = depth * this.verticalSpacing;
                    // Increment X for the next node in the in-order sequence
                    nextX += (this.nodeRadius * 2 + this.baseHorizontalSpacing);

                    const pos = { node: n, x: x, y: y, children: [], parentPos: null };
                    positions.set(n, pos);

                    // Update bounds tracking
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);

                    // Recurse right
                    computeInitialPositions.call(this, n.right, depth + 1);
                }

                // Second pass: Adjust positions (e.g., center parent over children)
                // This basic version just connects children; no complex adjustments.
                function buildHierarchy(pos) {
                    const n = pos.node;
                    if (n.left !== this.tree.NIL) {
                        const leftPos = positions.get(n.left);
                        if (leftPos) {
                            pos.children.push(leftPos);
                            leftPos.parentPos = pos;
                            buildHierarchy.call(this, leftPos);
                        }
                    }
                    if (n.right !== this.tree.NIL) {
                        const rightPos = positions.get(n.right);
                        if (rightPos) {
                            pos.children.push(rightPos);
                            rightPos.parentPos = pos;
                            buildHierarchy.call(this, rightPos);
                        }
                    }
                }


                computeInitialPositions.call(this, node, 0); // Start depth 0
                const rootPos = positions.get(node);
                if (rootPos) {
                    buildHierarchy.call(this, rootPos);
                }


                // Basic Centering Adjustment (Optional - can cause overlaps if not careful)
                // A proper algorithm would handle overlaps. This is simplified.
                function centerParents(pos) {
                    if (!pos || pos.children.length === 0) return;

                    pos.children.forEach(centerParents); // Adjust children first (post-order)

                    if (pos.children.length > 0) {
                        let firstChild = pos.children[0];
                        let lastChild = pos.children[pos.children.length - 1];
                        let desiredParentX = (firstChild.x + lastChild.x) / 2;
                        let currentParentX = pos.x;
                        let shift = desiredParentX - currentParentX;

                        if (shift !== 0) {
                            // Shift the parent and its entire subtree rooted at pos
                            shiftSubtree(pos, shift);
                        }
                    }
                }

                function shiftSubtree(pos, amount) {
                    if (!pos) return;
                    pos.x += amount;
                    // Update bounds after shift
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    pos.children.forEach(child => shiftSubtree(child, amount));
                }

                if (rootPos) {
                    // centerParents(rootPos); // Uncomment to enable basic centering
                    // Recalculate bounds if centering is enabled
                    // minX = Infinity; maxX = -Infinity;
                    // positions.forEach(p => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); });
                }


                return { rootPos, minX, maxX, minY, maxY }; // Return layout info
            }


            // Recursively draws edges and nodes starting from posData
            drawNodeAndEdges(group, posData) {
                if (!posData || !posData.node || posData.node.isNIL) return; // Stop if no data or NIL
                const { node, x, y, children } = posData;

                // Draw edges to children first (so they are underneath nodes)
                children.forEach(childPos => {
                    if (!childPos || childPos.node.isNIL) return; // Don't draw edge to NIL placeholder

                    const edge = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    edge.setAttribute('x1', x);
                    edge.setAttribute('y1', y);
                    edge.setAttribute('x2', childPos.x);
                    edge.setAttribute('y2', childPos.y);
                    edge.setAttribute('class', 'edge');
                    group.appendChild(edge);

                    // Recurse to draw the child subtree
                    this.drawNodeAndEdges(group, childPos);
                });

                // Draw the current node's circle
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', this.nodeRadius);
                circle.setAttribute('class', `node-${node.color.toLowerCase()}`);
                group.appendChild(circle);

                // Draw the current node's value
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('class', 'node-text');
                text.textContent = node.value;
                group.appendChild(text);
            }


            updateView() {
                this.draw(); // Redraw the tree completely
            }

            // Clean up resources like observers
            destroy() {
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                }
                // Remove other listeners if necessary, though usually handled by page unload
            }
        }

        let visualizer = null; // Make visualizer accessible globally for cleanup/dark mode access

        document.addEventListener('DOMContentLoaded', function () {
            const rbTree = new RedBlackTree();
            const svgElement = document.getElementById('rbTreeCanvas');
            visualizer = new TreeVisualizer(svgElement, rbTree); // Assign to global var
            const statusElement = document.getElementById('status');

            // Helper to show status messages
            function showStatus(message, isError = false) {
                statusElement.textContent = message;
                statusElement.classList.remove('hidden');
                // Apply error styling if needed
                statusElement.classList.toggle('text-red-700', isError);
                statusElement.classList.toggle('dark:text-red-400', isError);

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    statusElement.classList.add('hidden');
                    // Remove error styling when hiding
                    statusElement.classList.remove('text-red-700', 'dark:text-red-400');
                }, 3000);
            }

            // --- Button Event Handlers ---
            document.getElementById('insertBtn').addEventListener('click', function () {
                const input = document.getElementById('nodeValue');
                const value = parseInt(input.value.trim()); // Trim whitespace

                if (isNaN(value) || value < 1 || value > 999) {
                    showStatus('Please enter a valid integer between 1 and 999', true);
                    return;
                }
                // Check if value already exists using the find method
                if (rbTree.find(value) !== null) {
                    showStatus(`Value ${value} already exists in the tree`, true);
                    input.value = ''; // Clear input even if exists
                    return;
                }

                rbTree.insert(value); // Insert the value
                visualizer.updateView(); // Redraw the tree
                input.value = ''; // Clear input field
                showStatus(`Inserted ${value}`);
            });

            document.getElementById('deleteBtn').addEventListener('click', function () {
                const input = document.getElementById('deleteValue');
                const value = parseInt(input.value.trim());

                if (isNaN(value) || value < 1 || value > 999) {
                    showStatus('Please enter a valid integer between 1 and 999', true);
                    return;
                }

                const deleted = rbTree.delete(value); // Attempt deletion
                visualizer.updateView(); // Redraw the tree
                input.value = ''; // Clear input field

                if (deleted) {
                    showStatus(`Deleted ${value}`);
                } else {
                    showStatus(`Value ${value} not found in the tree`, true);
                }
            });

            document.getElementById('resetBtn').addEventListener('click', function () {
                rbTree.clear(); // Clear the data structure
                visualizer.resetView(); // Reset position and redraw empty tree visualization
                showStatus('Tree reset');
            });

            document.getElementById('randomTreeBtn').addEventListener('click', function () {
                rbTree.clear(); // Clear existing tree data
                const nodeCount = Math.floor(Math.random() * 11) + 5; // Generate 5 to 15 nodes
                const values = new Set(); // Use a Set to ensure unique values
                // Generate unique random values (1-100 range)
                while (values.size < nodeCount) {
                    values.add(Math.floor(Math.random() * 100) + 1);
                }

                // Insert the generated values into the tree
                values.forEach(value => rbTree.insert(value));

                visualizer.resetView(); // Reset position and redraw the new tree
                showStatus(`Generated random tree with ${rbTree.nodeCount} nodes`);
            });


            // --- Input Enter Key Listeners ---
            document.getElementById('nodeValue').addEventListener('keyup', function (e) {
                if (e.key === 'Enter') {
                    document.getElementById('insertBtn').click(); // Trigger insert button click
                }
            });

            document.getElementById('deleteValue').addEventListener('keyup', function (e) {
                if (e.key === 'Enter') {
                    document.getElementById('deleteBtn').click(); // Trigger delete button click
                }
            });

            // Initial setup: Reset view (which includes drawing the initial empty state)
            visualizer.resetView();
        });

        // Cleanup listener for when the window/tab is closed
        window.addEventListener('unload', () => {
            if (visualizer) {
                visualizer.destroy(); // Clean up observer to prevent potential memory leaks
            }
        });

    </script>
</body>

</html>